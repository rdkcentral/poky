# This bbclass provides utility functions to aggregate layer-specific CVE reports into a unified manifest for the final product image.

# Enforce architecture-based directory structures for module CVE report deployment.
CVE_CHECK_RECIPE_FILE = "${CVE_CHECK_DIR}/${PACKAGE_ARCH}/${PN}"
CVE_CHECK_RECIPE_FILE_JSON = "${CVE_CHECK_DIR}/${PACKAGE_ARCH}/${PN}_cve.json"

LAYER_CVE_DOWNLOAD_DIR ?= "layer_cve"

# Enable cve check for all targets including packagegroup
do_build[recrdeptask] += "${@'do_cve_check' if d.getVar('CVE_CHECK_CREATE_MANIFEST') == '1' else ''}"

# Returns the source recipe for a given package and architecture using opkg info. This method is functionally correct but requires optimization to reduce overhead.
def get_pkg_src(d, pkgname, target_arch):
    import subprocess
    import bb

    rootfs_dir = d.getVar('IMAGE_ROOTFS')
    config_file = d.getVar("IPKGCONF_TARGET")
    opkg_cmd = bb.utils.which(d.getVar('PATH'), "opkg")

    if not opkg_cmd:
        bb.fatal("get_pkg_src: opkg executable not found in PATH")

    extra_args = d.getVar("OPKG_ARGS") or ""
    opkg_args = f"-f {config_file} -o {rootfs_dir} {extra_args}"

    if not pkgname or not target_arch:
        bb.fatal("get_pkg_src: package name and target_arch must be provided")

    cmd = f"{opkg_cmd} {opkg_args} info {pkgname}"

    try:
        cmd_output = subprocess.check_output(cmd, shell=True, stderr=subprocess.STDOUT, text=True)
    except subprocess.CalledProcessError as e:
        bb.fatal("get_pkg_src: opkg info failed for %s.\nCommand: %s\nOutput: %s" %(pkgname, cmd, e.output))

    source_val = None
    for block in cmd_output.strip().split("\n\n"):
        if not block.strip():
            continue
        pkg_info = {}
        for line in block.splitlines():
            if ": " in line:
                key, val = line.split(": ", 1)
                pkg_info[key.strip()] = val.strip()

        if pkg_info.get("Architecture") == target_arch:
            source_val = pkg_info.get("Source")
            break

    if source_val is None:
        bb.fatal("get_pkg_src: Could not find Source for %s with arch %s" %(pkgname, target_arch))

    pn = source_val.replace(".bb", "")
    pn = pn.split("_")[0].strip()
    return pn


def get_layer_cve_feed_dict(d):
    """
    Parses CVE_LAYER_FEED_PATH and returns a dictionary of {arch: url}.
    Validates format and ensures uniqueness of architectures and URLs.
    """
    import shlex

    spec = d.getVar("CVE_LAYER_FEED_PATH") or ""
    if not spec.strip():
        return {}

    feed_dict = {}
    seen_urls = set()

    entries = shlex.split(spec)
    for entry in entries:
        if "##" not in entry:
            bb.fatal("Invalid entry '%s'. Expected format: '<arch>##<url>'" %entry)

        arch, url = [x.strip() for x in entry.split("##", 1)]

        if not arch or not url:
            bb.fatal("Invalid entry '%s'. Arch or URL missing." %entry)

        if arch in feed_dict:
            bb.fatal("Duplicate architecture '%s' found in CVE_LAYER_FEED_PATH." %arch)

        if url in seen_urls:
            bb.fatal("Duplicate URL '%s' found in CVE_LAYER_FEED_PATH." %url)

        feed_dict[arch] = url
        seen_urls.add(url)

    return feed_dict


# Download the CVE release tarball from the path specified in CVE_LAYER_FEED_PATH.
python do_download_layers_cve () {
    import bb.fetch2

    dest_root = os.path.join(d.getVar("CVE_CHECK_DIR"), d.getVar("LAYER_CVE_DOWNLOAD_DIR"))
    bb.utils.mkdirhier(dest_root)

    feeds = get_layer_cve_feed_dict(d)
    if not feeds:
        bb.note("CVE_LAYER_FEED_PATH is empty, nothing to download.")
        return

    for arch, url in feeds.items():
        # Add subdir to avoid collisions
        url_with_params = url + f";subdir={arch}"

        try:
            bb.note("Fetching CVE layer for %s from %s" %(arch, url))
            fetcher = bb.fetch2.Fetch([url_with_params], d)
            fetcher.download()
            fetcher.unpack(dest_root)
            bb.note("Successfully unpacked %s to %s" %(arch, dest_root))
        except Exception as e:
            bb.fatal("Failed to fetch/unpack CVE layer for arch=%s: %s" %(arch, e))
}

# Download layer cve files for each arch configured
addtask do_download_layers_cve before do_rootfs
do_download_and_extract[vardeps] += "CVE_LAYER_FEED_PATH"


# Generate the final consolidated CVE manifest using released layer-level reports.
python layer_cve_check_write_rootfs_manifest () {
    """
    Create CVE manifest when building an image
    """

    import shutil
    import json
    from oe.rootfs import image_list_installed_packages
    from oe.cve_check import cve_check_merge_jsons, update_symlinks

    if d.getVar("CVE_CHECK_COPY_FILES") == "1":
        deploy_file = d.getVar("CVE_CHECK_RECIPE_FILE")
        if os.path.exists(deploy_file):
            bb.utils.remove(deploy_file)
        deploy_file_json = d.getVar("CVE_CHECK_RECIPE_FILE_JSON")
        if os.path.exists(deploy_file_json):
            bb.utils.remove(deploy_file_json)

    # Create a list of relevant recipies
    recipies = set()
    recipe_arch_map = {}
    installed_pkgs_info = image_list_installed_packages(d)
    for pkg, pkg_meta in installed_pkgs_info.items():
        arch = pkg_meta.get("arch").strip()
        if not arch:
            bb.fatal("The pkg (%s) arch is not available - %s" %(pkg))
        recipe = get_pkg_src(d, pkg, arch)
        if not recipe :
            bb.fatal("Unable to find the package source for %s" %(pkg))
        recipies.add(recipe)

        if recipe in recipe_arch_map:
            if recipe_arch_map[recipe] != arch:
                bb.fatal("The recipe (%s) has configured with multiple arch (%s, %s)" %(recipe, recipe_arch_map[recipe], arch))
        else:
            recipe_arch_map[recipe] = arch
    bb.note("Writing rootfs CVE manifest")
    deploy_dir = d.getVar("IMGDEPLOYDIR")
    link_name = d.getVar("IMAGE_LINK_NAME")

    json_data = {"version":"1", "package": []}
    text_data = ""
    enable_json = d.getVar("CVE_CHECK_FORMAT_JSON") == "1"
    enable_text = d.getVar("CVE_CHECK_FORMAT_TEXT") == "1"

    layer_cve_feeds = get_layer_cve_feed_dict(d)

    for pkg in recipies:
        if enable_text:
            pkgfilepath = os.path.join(d.getVar("CVE_CHECK_DIR"), recipe_arch_map[pkg], pkg)
            if recipe_arch_map[pkg] in layer_cve_feeds:
                pkgfilepath = os.path.join(d.getVar("CVE_CHECK_DIR"), d.getVar("LAYER_CVE_DOWNLOAD_DIR"), recipe_arch_map[pkg], pkg)
            if os.path.exists(pkgfilepath):
                with open(pkgfilepath) as pfile:
                    text_data += pfile.read()

        if enable_json:
            pkgfilepath = os.path.join(d.getVar("CVE_CHECK_DIR"), recipe_arch_map[pkg], pkg+"_cve.json")
            if recipe_arch_map[pkg] in layer_cve_feeds:
                pkgfilepath = os.path.join(d.getVar("CVE_CHECK_DIR"), d.getVar("LAYER_CVE_DOWNLOAD_DIR"), recipe_arch_map[pkg], pkg+"_cve.json")
            if os.path.exists(pkgfilepath):
                with open(pkgfilepath) as j:
                    data = json.load(j)
                    cve_check_merge_jsons(json_data, data)


    if enable_text:
        link_path = os.path.join(deploy_dir, "%s.cve" % link_name)
        manifest_name = d.getVar("CVE_CHECK_MANIFEST")

        with open(manifest_name, "w") as f:
            f.write(text_data)

        update_symlinks(manifest_name, link_path)
        bb.plain("Image CVE report stored in: %s" % manifest_name)

    if enable_json:
        link_path = os.path.join(deploy_dir, "%s.json" % link_name)
        manifest_name = d.getVar("CVE_CHECK_MANIFEST_JSON")

        with open(manifest_name, "w") as f:
            json.dump(json_data, f, indent=2)

        update_symlinks(manifest_name, link_path)
        bb.plain("Image CVE JSON report stored in: %s" % manifest_name)
}

